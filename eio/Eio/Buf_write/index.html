<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Buf_write (eio.Eio.Buf_write)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Buf_write</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Buf_write</span></code></h1><p>Buffered output</p><p>Serialization primitives built for speed and memory-efficiency.</p><p>Buf_write is a library for writing fast and memory-efficient serializers, based on the Faraday library but adapted for Eio. Its core type and related operation gives the user fine-grained control over copying and allocation behavior while serializing user-defined types, and presents the output in a form that makes it possible to use vectorized write operations, such as the <code>writev</code> system call, or any other platform or application-specific output APIs.</p><p>A Buf_write serializer manages an internal buffer and a queue of output buffers. The output bufferes may be a sub range of the serializer's internal buffer or one that is user-provided. Buffered writes such as <a href="#val-write_string"><code>write_string</code></a>, <a href="#val-write_char"><code>write_char</code></a>, <a href="#val-write_cstruct"><code>write_cstruct</code></a>, etc., copy the source bytes into the serializer's internal buffer. Unbuffered writes such as <code>schedule_string</code>, <a href="#val-schedule_cstruct"><code>schedule_cstruct</code></a>, etc., on the other hand perform no copying. Instead, they enqueue the source bytes into the serializer's write queue directly.</p></header><nav class="odoc-toc"><ul><li><a href="#running">Running</a></li><li><a href="#buffered-writes">Buffered Writes</a></li><li><a href="#unbuffered-writes">Unbuffered Writes</a></li><li><a href="#querying-a-serializer's-state">Querying A Serializer's State</a></li><li><a href="#control-operations">Control Operations</a></li><li><a href="#low-level-api">Low-level API</a></li><li><a href="#convenience-functions">Convenience Functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of a serializer.</p></div></div><h3 id="running"><a href="#running" class="anchor"></a>Running</h3><div class="odoc-spec"><div class="spec value" id="val-with_flow" class="anchored"><a href="#val-with_flow" class="anchor"></a><code><span><span class="keyword">val</span> with_flow : <span>?initial_size:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Flow/class-sink/index.html">Flow.sink</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_flow flow fn</code> runs <code>fn writer</code>, where <code>writer</code> is a buffer that flushes to <code>flow</code>. Concurrently with <code>fn</code>, it also runs a fiber that copies from <code>writer</code> to <code>flow</code>. If this fiber runs out of data to copy then it will suspend itself. Writing to <code>writer</code> will automatically schedule it to be resumed. This means that pending data is always flushed automatically before the process sleeps. When <code>fn</code> returns, <code>writer</code> is automatically closed and any remaining data is flushed before <code>with_flow</code> itself returns.</p></div></div><h3 id="buffered-writes"><a href="#buffered-writes" class="anchor"></a>Buffered Writes</h3><p>A serializer manages an internal buffer for coalescing small writes. The size of this buffer is determined when the serializer is created. If the buffer does not contain sufficient space to service a caller's buffered write, the serializer will allocate a new buffer of the sufficient size and use it for the current and subsequent writes. The old buffer will be garbage collected once all of its contents have been <a href="#val-flush"><code>flush</code></a>ed.</p><div class="odoc-spec"><div class="spec value" id="val-write_string" class="anchored"><a href="#val-write_string" class="anchor"></a><code><span><span class="keyword">val</span> write_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_string t ?off ?len str</code> copies <code>str</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_bytes" class="anchored"><a href="#val-write_bytes" class="anchor"></a><code><span><span class="keyword">val</span> write_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?off:int <span class="arrow">&#45;&gt;</span></span> <span>?len:int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_bytes t ?off ?len bytes</code> copies <code>bytes</code> into the serializer's internal buffer. It is safe to modify <code>bytes</code> after this call returns.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_cstruct" class="anchored"><a href="#val-write_cstruct" class="anchor"></a><code><span><span class="keyword">val</span> write_cstruct : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_cstruct t cs</code> copies <code>cs</code> into the serializer's internal buffer. It is safe to modify <code>cs</code> after this call returns.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_gen" class="anchored"><a href="#val-write_gen" class="anchor"></a><code><span><span class="keyword">val</span> write_gen : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>length:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>blit:
    <span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>src_off:int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.buffer <span class="arrow">&#45;&gt;</span></span> <span>dst_off:int <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?off:int <span class="arrow">&#45;&gt;</span></span>
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>write_gen t ~length ~blit ?off ?len x</code> copies <code>x</code> into the serializer's internal buffer using the provided <code>length</code> and <code>blit</code> operations. See <code>Bigstring</code>.blit for documentation of the arguments.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_char" class="anchored"><a href="#val-write_char" class="anchor"></a><code><span><span class="keyword">val</span> write_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_char t char</code> copies <code>char</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_uint8" class="anchored"><a href="#val-write_uint8" class="anchor"></a><code><span><span class="keyword">val</span> write_uint8 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_uint8 t n</code> copies the lower 8 bits of <code>n</code> into the serializer's internal buffer.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-BE" class="anchored"><a href="#module-BE" class="anchor"></a><code><span><span class="keyword">module</span> <a href="BE/index.html">BE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Big endian serializers</p></div></div><div class="odoc-spec"><div class="spec module" id="module-LE" class="anchored"><a href="#module-LE" class="anchor"></a><code><span><span class="keyword">module</span> <a href="LE/index.html">LE</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Little endian serializers</p></div></div><h3 id="unbuffered-writes"><a href="#unbuffered-writes" class="anchor"></a>Unbuffered Writes</h3><p>Unbuffered writes do not involve copying bytes to the serializer's internal buffer.</p><div class="odoc-spec"><div class="spec value" id="val-schedule_cstruct" class="anchored"><a href="#val-schedule_cstruct" class="anchor"></a><code><span><span class="keyword">val</span> schedule_cstruct : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>schedule_cstruct t cs</code> schedules <code>cs</code> to be written. <code>cs</code> is not copied in this process, so <code>cs</code> should only be modified after <code>t</code> has been <a href="#val-flush"><code>flush</code></a>ed.</p></div></div><h3 id="querying-a-serializer's-state"><a href="#querying-a-serializer's-state" class="anchor"></a>Querying A Serializer's State</h3><div class="odoc-spec"><div class="spec value" id="val-free_bytes_in_buffer" class="anchored"><a href="#val-free_bytes_in_buffer" class="anchor"></a><code><span><span class="keyword">val</span> free_bytes_in_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>free_bytes_in_buffer t</code> returns the free space, in bytes, of the serializer's write buffer. If a <code>write_*</code> call has a length that exceeds this value, the serializer will allocate a new buffer that will replace the serializer's internal buffer for that and subsequent calls.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-has_pending_output" class="anchored"><a href="#val-has_pending_output" class="anchor"></a><code><span><span class="keyword">val</span> has_pending_output : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>has_pending_output t</code> is <code>true</code> if <code>t</code>'s output queue is non-empty. It may be the case that <code>t</code>'s queued output is being serviced by some other thread of control, but has not yet completed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pending_bytes" class="anchored"><a href="#val-pending_bytes" class="anchor"></a><code><span><span class="keyword">val</span> pending_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>pending_bytes t</code> is the size of the next write, in bytes, that <code>t</code> will surface to the caller from <a href="#val-pending"><code>pending</code></a>.</p></div></div><h3 id="control-operations"><a href="#control-operations" class="anchor"></a>Control Operations</h3><div class="odoc-spec"><div class="spec value" id="val-pause" class="anchored"><a href="#val-pause" class="anchor"></a><code><span><span class="keyword">val</span> pause : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pause t</code> causes <code>t</code> to stop surfacing writes to the user. This gives the serializer an opportunity to collect additional writes before sending them to the underlying device, which will increase the write batch size.</p><p>As one example, code may want to call this function if it's about to release the OCaml lock and perform a blocking system call, but would like to batch output across that system call.</p><p>Call <a href="#val-unpause"><code>unpause</code></a> to resume writing later. Note that calling <a href="#val-flush"><code>flush</code></a> or <a href="#val-close"><code>close</code></a> will automatically call <a href="#val-unpause"><code>unpause</code></a> too.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unpause" class="anchored"><a href="#val-unpause" class="anchor"></a><code><span><span class="keyword">val</span> unpause : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>unpause t</code> resumes writing data after a previous call to <a href="#val-pause"><code>pause</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flush" class="anchored"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>flush t</code> waits until all prior writes have been successfully completed. If <code>t</code> has no pending writes, <code>flush</code> returns immediately. If <code>t</code> is paused then it is unpaused first.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close t</code> closes <code>t</code>. All subsequent write calls will raise, and any pending or subsequent <code>yield</code> calls will be ignored. If the serializer has any pending writes, user code will have an opportunity to service them before it receives the <code>Close</code> operation. Flush callbacks will continue to be invoked while output is <a href="#val-shift"><code>shift</code></a>ed out of <code>t</code> as needed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_closed" class="anchored"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed t</code> is <code>true</code> if <code>close</code> has been called on <code>t</code> and <code>false</code> otherwise. A closed <code>t</code> may still have pending output.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shift" class="anchored"><a href="#val-shift" class="anchor"></a><code><span><span class="keyword">val</span> shift : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>shift t n</code> removes the first <code>n</code> bytes in <code>t</code>'s write queue. Any flush callbacks registered with <code>t</code> within this span of the write queue will be called.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drain" class="anchored"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>drain t</code> removes all pending writes from <code>t</code>, returning the number of bytes that were enqueued to be written and freeing any scheduled buffers in the process.</p></div></div><h3 id="low-level-api"><a href="#low-level-api" class="anchor"></a>Low-level API</h3><p>Low-level operations for running a serializer.</p><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create len</code> creates a serializer with a fixed-length internal buffer of length <code>len</code>. See the Buffered writes section for details about what happens when <code>len</code> is not large enough to support a write.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_buffer" class="anchored"><a href="#val-of_buffer" class="anchor"></a><code><span><span class="keyword">val</span> of_buffer : <span><span class="xref-unresolved">Cstruct</span>.buffer <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_buffer buf</code> creates a serializer, using <code>buf</code> as its internal buffer. The serializer takes ownership of <code>buf</code> until the serializer has been closed and flushed of all output.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pending" class="anchored"><a href="#val-pending" class="anchor"></a><code><span><span class="keyword">val</span> pending : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t list</span></span></code></div><div class="spec-doc"><p><code>pending t</code> is a list of buffers that should be written next. If no data is currently available, it waits until some is. After performing a write, call <a href="#val-shift"><code>shift</code></a> with the number of bytes written. You must accurately report the number of bytes written. Failure to do so will result in the same bytes being surfaced multiple times. If <code>yield</code> has been called, <code>pending t</code> will call <code>Fiber</code>.yield() once before continuing.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">End_of_file</span> <p>If there is nothing left to write.</p></li></ul></div></div><h3 id="convenience-functions"><a href="#convenience-functions" class="anchor"></a>Convenience Functions</h3><p>These functions are included for testing, debugging, and general development. They are not the suggested way of driving a serializer in a production setting.</p><div class="odoc-spec"><div class="spec value" id="val-serialize" class="anchored"><a href="#val-serialize" class="anchor"></a><code><span><span class="keyword">val</span> serialize : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="arrow">&#45;&gt;</span></span> <span>[ <span>`Ok of int</span> <span>| `Closed</span> ]</span> )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>serialize t writev</code> sufaces the next operation of <code>t</code> to the caller, handling a <code>`Writev</code> operation with <code>writev</code> function and performing an additional bookkeeping on the caller's behalf. In the event that <code>writev</code> indicates a partial write, <a href="#val-serialize"><code>serialize</code></a> will call <code>yield</code> on the serializer rather than attempting successive <code>writev</code> calls.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-serialize_to_string" class="anchored"><a href="#val-serialize_to_string" class="anchor"></a><code><span><span class="keyword">val</span> serialize_to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>serialize_to_string t</code> runs <code>t</code>, collecting the output into a string and returning it. <code>serialzie_to_string t</code> immediately closes <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-serialize_to_cstruct" class="anchored"><a href="#val-serialize_to_cstruct" class="anchor"></a><code><span><span class="keyword">val</span> serialize_to_cstruct : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cstruct</span>.t</span></code></div><div class="spec-doc"><p><code>serialize_to_cstruct t</code> runs <code>t</code>, collecting the output into a cstruct and returning it. <code>serialize_to_cstruct t</code> immediately closes <code>t</code>.</p></div></div></div></body></html>