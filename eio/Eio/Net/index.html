<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Net (eio.Eio.Net)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Net</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Net</span></code></h1><p>Networking.</p><p>Example:</p><pre><code>let addr = `Tcp (Ipaddr.V4.loopback, 8080)

let http_get ~net ~stdout addr =
  Switch.run @@ fun sw -&gt;
  let flow = Net.connect ~sw net addr in
  Flow.copy_string &quot;GET / HTTP/1.0\r\n\r\n&quot; flow;
  Flow.shutdown flow `Send;
  Flow.copy flow stdout</code></pre></header><nav class="odoc-toc"><ul><li><a href="#provider-interfaces">Provider Interfaces</a></li><li><a href="#out-bound-connections">Out-bound Connections</a></li><li><a href="#incoming-connections">Incoming Connections</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec exception" id="exception-Connection_reset" class="anchored"><a href="#exception-Connection_reset" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Connection_reset</span> <span class="keyword">of</span> exn</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Ipaddr" class="anchored"><a href="#module-Ipaddr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Ipaddr/index.html">Ipaddr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>IP addresses.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Sockaddr" class="anchored"><a href="#module-Sockaddr" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Sockaddr/index.html">Sockaddr</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Network addresses.</p></div></div><h3 id="provider-interfaces"><a href="#provider-interfaces" class="anchor"></a>Provider Interfaces</h3><div class="odoc-spec"><div class="spec class" id="class-listening_socket" class="anchored"><a href="#class-listening_socket" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-listening_socket/index.html">listening_socket</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec class" id="class-t" class="anchored"><a href="#class-t" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">virtual</span>  </span><span><a href="class-t/index.html">t</a></span><span> : <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="out-bound-connections"><a href="#out-bound-connections" class="anchor"></a>Out-bound Connections</h3><div class="odoc-spec"><div class="spec value" id="val-connect" class="anchored"><a href="#val-connect" class="anchor"></a><code><span><span class="keyword">val</span> connect : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-t">Sockaddr.t</a> <span class="arrow">&#45;&gt;</span></span> <span>&lt; <a href="../Flow/class-two_way/index.html">Flow.two_way</a>; <a href="../Flow/class-type-close/index.html">Flow.close</a>; &gt;</span></span></code></div><div class="spec-doc"><p><code>connect ~sw t addr</code> is a new socket connected to remote address <code>addr</code>.</p><p>The new socket will be closed when <code>sw</code> finishes, unless closed manually first.</p></div></div><h3 id="incoming-connections"><a href="#incoming-connections" class="anchor"></a>Incoming Connections</h3><div class="odoc-spec"><div class="spec value" id="val-listen" class="anchored"><a href="#val-listen" class="anchor"></a><code><span><span class="keyword">val</span> listen : <span>?reuse_addr:bool <span class="arrow">&#45;&gt;</span></span> <span>?reuse_port:bool <span class="arrow">&#45;&gt;</span></span> <span>backlog:int <span class="arrow">&#45;&gt;</span></span> <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-t">Sockaddr.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="class-listening_socket/index.html">listening_socket</a></span></code></div><div class="spec-doc"><p><code>listen ~sw ~backlog t addr</code> is a new listening socket bound to local address <code>addr</code>.</p><p>The new socket will be closed when <code>sw</code> finishes, unless closed manually first.</p><p>For (non-abstract) Unix domain sockets, the path will be removed afterwards.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">backlog</span> <p>The number of pending connections that can be queued up (see listen(2)).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">reuse_addr</span> <p>Set the <code>Unix</code>.SO_REUSEADDR socket option. For Unix paths, also remove any stale left-over socket.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">reuse_port</span> <p>Set the <code>Unix</code>.SO_REUSEPORT socket option.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-accept" class="anchored"><a href="#val-accept" class="anchor"></a><code><span><span class="keyword">val</span> accept : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">listening_socket</span> <span class="arrow">&#45;&gt;</span></span> <span>&lt; <a href="../Flow/class-two_way/index.html">Flow.two_way</a>; <a href="../Flow/class-type-close/index.html">Flow.close</a>; &gt;</span> * <a href="Sockaddr/index.html#type-t">Sockaddr.t</a></span></code></div><div class="spec-doc"><p><code>accept ~sw socket</code> waits until a new connection is ready on <code>socket</code> and returns it.</p><p>The new socket will be closed automatically when <code>sw</code> finishes, if not closed earlier. If you want to handle multiple connections, consider using <a href="#val-accept_sub"><code>accept_sub</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-accept_sub" class="anchored"><a href="#val-accept_sub" class="anchor"></a><code><span><span class="keyword">val</span> accept_sub : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">listening_socket</span> <span class="arrow">&#45;&gt;</span></span> <span>on_error:<span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>&lt; <a href="../Flow/class-two_way/index.html">Flow.two_way</a>; <a href="../Flow/class-type-close/index.html">Flow.close</a>; &gt;</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Sockaddr/index.html#type-t">Sockaddr.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>accept socket fn</code> accepts a connection and handles it in a new fibre.</p><p>After accepting a connection to <code>socket</code>, it runs <code>fn ~sw flow client_addr</code> in a new fibre, using <a href="../Fibre/index.html#val-fork_on_accept"><code>Fibre.fork_on_accept</code></a>.</p><p><code>flow</code> will be closed automatically when the sub-switch is finished, if not already closed by then.</p></div></div></div></body></html>