<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fiber (eio.Eio.Fiber)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Fiber</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Fiber</span></code></h1><p>A fiber is a light-weight thread.</p><p>Within a domain, only one fiber can be running at a time. A fiber runs until it performs an IO operation (directly or indirectly). At that point, it may be suspended and the next fiber on the run queue runs.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>both f g</code> runs <code>f ()</code> and <code>g ()</code> concurrently.</p><p>They run in a new cancellation sub-context, and if either raises an exception, the other is cancelled. <code>both</code> waits for both functions to finish even if one raises (it will then re-raise the original exception).</p><p><code>f</code> runs immediately, without switching to any other thread. <code>g</code> is inserted at the head of the run-queue, so it runs next even if other threads are already enqueued. You can get other scheduling orders by adding calls to <a href="#val-yield"><code>yield</code></a> in various places. e.g. to append both fibers to the end of the run-queue, yield immediately before calling <code>both</code>.</p><p>If both fibers fail, <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to combine the exceptions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pair" class="anchored"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>pair f g</code> is like <code>both</code>, but returns the two results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>all fs</code> is like <code>both</code>, but for any number of fibers. <code>all []</code> returns immediately.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>first f g</code> runs <code>f ()</code> and <code>g ()</code> concurrently.</p><p>They run in a new cancellation sub-context, and when one finishes the other is cancelled. If one raises, the other is cancelled and the exception is reported.</p><p>As with <code>both</code>, <code>f</code> runs immediately and <code>g</code> is scheduled next, ahead of any other queued work.</p><p>If both fibers fail, <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to combine the exceptions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>any fs</code> is like <code>first</code>, but for any number of fibers.</p><p><code>any []</code> just waits forever (or until cancelled).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-await_cancel" class="anchored"><a href="#val-await_cancel" class="anchor"></a><code><span><span class="keyword">val</span> await_cancel : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await_cancel ()</code> waits until cancelled.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Cancel.Cancelled</span> </li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fork" class="anchored"><a href="#val-fork" class="anchor"></a><code><span><span class="keyword">val</span> fork : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fork ~sw fn</code> runs <code>fn ()</code> in a new fiber, but does not wait for it to complete.</p><p>The new fiber is attached to <code>sw</code> (which can't finish until the fiber ends).</p><p>The new fiber inherits <code>sw</code>'s cancellation context. If the fiber raises an exception, <code>Switch.fail sw</code> is called. If <code>sw</code> is already off then <code>fn</code> fails immediately, but the calling thread continues.</p><p><code>fn</code> runs immediately, without switching to any other fiber first. The calling fiber is placed at the head of the run queue, ahead of any previous items.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fork_sub" class="anchored"><a href="#val-fork_sub" class="anchor"></a><code><span><span class="keyword">val</span> fork_sub : 
  <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>on_error:<span>( <span>exn <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>fork_sub ~sw ~on_error fn</code> is like <code>fork</code>, but it creates a new sub-switch for the fiber.</p><p>This means that you can cancel the child switch without cancelling the parent. This is a convenience function for running <a href="../Switch/index.html#val-run"><code>Switch.run</code></a> inside a <a href="#val-fork"><code>fork</code></a>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">on_error</span> <p>This is called if the fiber raises an exception. If it raises in turn, the parent switch is failed. It is not called if the parent <code>sw</code> itself is cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fork_on_accept" class="anchored"><a href="#val-fork_on_accept" class="anchor"></a><code><span><span class="keyword">val</span> fork_on_accept : 
  <span>on_handler_error:<span>( <span>exn <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>fork_on_accept ~sw accept handle ~on_handler_error</code> creates a new sub-switch <code>t</code>. It runs <code>accept t</code> in the current fiber and, on success, runs <code>handle t result</code> in a new fiber. It is useful for e.g. accepting network connections, where we need to provide a switch for the new client socket before we have forked, but then move it to a child fiber later.</p><p>If <code>accept</code> raises an exception then the effect is the same as <code>Switch.run accept</code>. If <code>handle</code> raises an exception, it is passed to <code>on_handler_error</code>. If that raises in turn, the parent switch is failed. <code>on_handler_error</code> is not called if the parent <code>sw</code> is itself cancelled.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fork_promise" class="anchored"><a href="#val-fork_promise" class="anchor"></a><code><span><span class="keyword">val</span> fork_promise : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Promise/index.html#type-or_exn">Promise.or_exn</a></span></span></code></div><div class="spec-doc"><p><code>fork_promise ~sw fn</code> schedules <code>fn ()</code> to run in a new fiber and returns a promise for its result.</p><p>This is just a convenience wrapper around <a href="#val-fork"><code>fork</code></a>. If <code>fn</code> raises an exception then the promise is resolved to the error, but <code>sw</code> is not failed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check" class="anchored"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>check ()</code> checks that the fiber's context hasn't been cancelled. Many operations automatically check this before starting.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Cancel.Cancelled</span> <p>if the fiber's context has been cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-yield" class="anchored"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> asks the scheduler to switch to the next runnable task. The current task remains runnable, but goes to the back of the queue. Automatically calls <a href="#val-check"><code>check</code></a> just before resuming.</p></div></div></div></body></html>